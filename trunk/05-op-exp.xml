<chapter id="operators-expressions">
	
	<!-- German Translation 2005-02-27 by Bernd Hengelein -->
	
	<!--<title>Operators and Expressions</title>-->
	<title>Operatoren und Ausdrücke</title>
	
	<section id="operators-expressions-intro">
		<!--<title>Introduction</title>-->
		<title>Einführung</title>
		
		<para>
		Die meisten Anweisungen die Sie schreiben, werden <emphasis role="bold">Ausdrücke</emphasis>
		enthalten. Ein einfacher Ausdruck ist z.B. <literal>2 + 3</literal>.
		Ein Ausdruck besteht aus Operatoren und Operanden.
		
		<!--
		Most statements (logical lines) that you write will contain
		<emphasis role="bold">expressions</emphasis>. A simple example of an expression is
		<literal>2 + 3</literal>. An expression can be broken down into operators and operands.
		-->
		
		</para>
		<para>
		<emphasis>Operatoren</emphasis> bieten eine bestimmte Funktionalität und können Symbole wie
		<literal>+</literal>, oder besondere Schlüsselwörter sein. Die Daten mit denen
		Operatoren verwendet werden, nennt man <emphasis>Operanden</emphasis>. In unserem
		Beispiel sind <literal>2</literal> und <literal>3</literal> die Operanden.
		
		<!--
		<emphasis>Operators</emphasis> are functionality that do something and can be
		represented by symbols such as <literal>+</literal> or by special keywords. Operators
		require some data to operate on and such data are called <emphasis>operands</emphasis>.
		In this case, <literal>2</literal> and <literal>3</literal> are the operands.
		-->
		
		</para>
	</section>
	
	<section id="operators">
		<title>Operatoren</title><!--<title>Operators</title>-->
		
		<para>
		
		Lassen Sie uns einen kurzen Blick auf die Operatoren und ihre Anwendung werfen:
		<!--
		We will briefly take a look at the operators and their usage:
		-->
		
		</para>
		<tip>
			<para>
			
			Die Ausdrücke aus den Beispielen können mit dem Interpreter interaktiv
			ausgewertet werden. Um z.B. den Ausdruck <literal>2 + 3</literal> zu testen,
			geben Sie folgendes in der Kommandozeile des Interpreters ein:
			
			<!--
			You can evaluate the expressions given in the examples using the interpreter
			interactively. For example, to test the expression <literal>2 + 3</literal>, use
			the interactive Python interpreter prompt:
			-->
			
			</para>
			<screen>
			<![CDATA[
>>> 2 + 3
5
>>> 3 * 5
15
>>>
			]]>
			</screen>
		</tip>
		
		<table>
			<!--
			<title>Operators and their usage</title>
			-->
			<title>Operatoren und wie sie verwendet werden</title>
			<tgroup cols="4">
				<thead>
					<row>
						<entry>Operator</entry>
						<entry>Name</entry>
						<entry>Erklärung</entry><!--<entry>Explanation</entry>-->
						<entry>Beispiele</entry><!--<entry>Examples</entry>-->
					</row>
				</thead>
				<tbody>
					<row>
						<entry>+</entry>
						<entry>Addition</entry>
						<!--<entry>Plus</entry>-->
						<entry>
						
						Addiert bzw. verkettet die beiden Objekte
						<!--Adds the two objects-->
						
						</entry>
						<entry>
						
						<literal>3 + 5</literal> ergibt <literal>8</literal>.
						<!--<literal>3 + 5</literal> gives <literal>8</literal>.-->
						<literal>'a' + 'b'</literal> ergibt <literal>'ab'</literal>.
						<!--<literal>'a' + 'b'</literal> gives <literal>'ab'</literal>.-->
						
						</entry>
					</row>
					<row>
						<entry>-</entry>
						<entry>Subtraktion</entry>
						<!--<entry>Minus</entry>-->
						<entry>
						
						Ergiebt entweder eine negative Zahl, oder das Ergebnis
						einer Subtraktion zweier Zahlen
						<!--
						Either gives a negative number or gives the subtraction of
						one number from the other
						-->
						
						</entry>
						<entry>
						
						<literal>-5.2</literal> ergibt eine negative Zahl.
						<literal>50 - 24</literal> ergibt <literal>26</literal>.
						<!--
						<literal>-5.2</literal> gives a negative number.
						<literal>50 - 24</literal> gives <literal>26</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>*</entry>
						<entry>Multiplikation</entry>
						<!--<entry>Multiply</entry>-->
						<entry>
						
						Multipliziert zwei Zahlen miteinander oder wiederholt einen String
						n-mal.
						<!--
						Gives the multiplication of the two numbers or returns
						the string repeated that many times.
						-->
						
						</entry>
						<entry>
						
						<literal>2 * 3</literal> ergibt <literal>6</literal>.
						<literal>'la' * 3</literal> ergibt <literal>'lalala'</literal>.
						<!--
						<literal>2 * 3</literal> gives <literal>6</literal>.
						<literal>'la' * 3</literal> gives <literal>'lalala'</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>**</entry>
						<entry>Potenz</entry>
						<!--<entry>Power</entry>-->
						<entry>
						
						Potenziert die Basis x mit dem Faktor y.
						<!--
						Returns x to the power of y
						-->
						
						</entry>
						<entry>
						
						<literal>3 ** 4</literal> erbgiebt <literal>81</literal>
						(d.h. <literal>3 * 3 * 3 * 3</literal>)
						<!--
						<literal>3 ** 4</literal> gives <literal>81</literal>
						(i.e. <literal>3 * 3 * 3 * 3</literal>)
						-->
						
						</entry>
					</row>
					<row>
						<entry>/</entry>
						<entry>Division</entry>
						<!--<entry>Divide</entry>-->
						<entry>
						
						Dividiere x durch y
						<!--
						Divide x by y
						-->
						
						</entry>
						<entry>
						
						<literal>4/3</literal> ergibt <literal>1</literal> (die Division
						von Ganzzahlen ergibt wieder eine Ganzzahl).
						<literal>4.0/3</literal> oder <literal>4/3.0</literal> ergibt
						<literal>1.3333333333333333</literal>
						<!--
						<literal>4/3</literal> gives <literal>1</literal> (division
						of integers gives an integer).
						<literal>4.0/3</literal> or <literal>4/3.0</literal> gives
						<literal>1.3333333333333333</literal>
						-->
						
						</entry>
					</row>
					<row>
						<entry>//</entry>
						<entry>Restlose Division</entry>
						<!--<entry>Floor Division</entry>-->
						<entry>
						
						Liefert als Ergebnis den Ganzzahlquotient (todo: gehts besser?) der Division
						<!--
						Returns the floor of the quotient
						-->
						
						</entry>
						<entry>
						
						<literal>4 // 3.0</literal> ergibt <literal>1.0</literal>
						<!--<literal>4 // 3.0</literal> gives <literal>1.0</literal>-->
						
						</entry>
					</row>
					<row>
						<entry>%</entry>
						<entry>Modulo</entry>
						<entry>
						
						Liefert den Rest einer Ganzzahldivision
						<!--Returns the remainder of the division-->
						
						</entry>
						<entry>
						
						<literal>8%3</literal> ergibt <literal>2</literal>.
						<literal>-25.5%2.25</literal> ergibt <literal>1.5</literal> .
						<!--
						<literal>8%3</literal> gives <literal>2</literal>.
						<literal>-25.5%2.25</literal> gives <literal>1.5</literal> .
						-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[<<]]></entry>
						<entry>Bitweises Linksschieben</entry><!--<entry>Left Shift</entry>-->
						<entry>
						
						Verschiebt das Bitmuster des linken Operanden um die angegebene
						Anzahl von Bit-Positionen nach links. (Jede Zahl wird im Speicher
						durch Bits, d.h. die Binärzeichen 0 und 1 repräsentiert)
						<!--
						Shifts the bits of the number to the left by the number of
						bits specified. (Each number is represented in memory by
						bits or binary digits i.e. 0 and 1)
						-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[2 << 2]]></literal> ergibt
						<literal>8</literal>.
						- <literal>2</literal> wird durch das Bitmuster
						<literal>10</literal> repräsentiert. Eine Verschiebung um 2 Bits
						nach links ergibt <literal>1000</literal>, was wiederum der
						Dezimalzahl <literal>8</literal> entspricht.
						<!--
						<literal><![CDATA[2 << 2]]></literal> gives
						<literal>8</literal>.
						- <literal>2</literal> is represented by
						<literal>10</literal> in bits. Left shifting by 2 bits
						gives <literal>1000</literal> which represents the
						decimal <literal>8</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[>>]]></entry>
						<entry>Bitweises Rechtsschieben</entry><!--<entry>Right Shift</entry>-->
						<entry>
						
						Verschiebt das Bitmuster des linken Operanden um die angegebene
						Anzahl von Bit-Positionen nach rechts.
						<!--
						Shifts the bits of the number to the right by the number
						of bits specified.
						-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[11 >> 1]]></literal> ergibt
						<literal>5</literal> -
						<literal>11</literal> wird durch das Bitmuster
						<literal>1011</literal> repräsentiert. Eine Verschiebung um 1 Bit
						nach rechts ergibt <literal>101</literal>, was wiederum der
						Dezimalzahl <literal>5</literal> entspricht.
						
						<!--
						<literal><![CDATA[11 >> 1]]></literal> gives
						<literal>5</literal> -
						<literal>11</literal> is represented in bits by
						<literal>1011</literal> which when right shifted by
						1 bit gives <literal>101</literal> which is nothing
						but decimal <literal>5</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[&]]></entry>
						<entry>Bitweises UND</entry><!--<entry>Bitwise AND</entry>-->
						<entry>
						
						Die Bitmuster der beiden Zahlen werden mit UND verknüpft
						<!--
						Bitwise AND of the numbers
						-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[5 & 3]]></literal> ergibt
						<literal>1</literal>.
						<!--
						<literal><![CDATA[5 & 3]]></literal> gives
						<literal>1</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>|</entry>
						<entry>Bitweises ODER</entry><!--<entry>Bit-wise OR</entry>-->
						<entry>
						
						Die Bitmuster der beiden Zahlen werden mit ODER verknüpft
						
						<!--Bitwise OR of the numbers-->
						
						</entry>
						<entry>
						
						<literal>5 | 3</literal> ergibt <literal>7</literal>
						<!--<literal>5 | 3</literal> gives <literal>7</literal>-->
						
						</entry>
					</row>
					<row>
						<entry>^</entry>
						<entry>Bitweises XOR (exclusives ODER)</entry><!--<entry>Bit-wise XOR</entry>-->
						<entry>
						
						<literal>5 ^ 3</literal> ergibt <literal>6</literal>
						<!--<literal>5 ^ 3</literal> gives <literal>6</literal>-->
						
						</entry>
					</row>
					<row>
						<entry>~</entry>
						<entry>Einer-Komplement</entry><!--<entry>Bit-wise invert</entry>-->
						<entry>
						
						Das Einer-Komplement einer Zahl x ergibt -(x+1)
						
						<!--The bit-wise inversion of x is -(x+1)-->
						
						</entry>
						<entry>
						
						<literal>~5</literal> ergibt <literal>-6</literal>.
						<!--<literal>~5</literal> gives <literal>-6</literal>.-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[<]]></entry>
						<entry>Kleiner als</entry><!--<entry>Less Than</entry>-->
						<entry>
						
						Das Ergebnis zeigt an, ob x kleiner ist als y. Aller Vergleichsoperatoren
						liefert als Rückgabewert 1 für wahr(true) und 0 für falsch(false).
						Das entspricht jeweils den speziellen Typen <literal>True</literal>
						und <literal>False</literal>. Beachten Sie die Großschreibung dieser
						Typnamen.
						<!--
						Returns whether x is less than y. All comparison operators
						return 1 for true and 0 for false. This is equivalent to
						the special variables <literal>True</literal> and
						<literal>False</literal> respectively. Note the
						capitalization of these variables' names.
						-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[5 < 3]]></literal> ergibt
						<literal>0</literal> (d.h. <literal>False</literal>) und
						<literal><![CDATA[3 < 5]]></literal> ergibt
						<literal>1</literal> (d.h. <literal>True</literal>).
						<!--
						<literal><![CDATA[5 < 3]]></literal> gives
						<literal>0</literal> (i.e. <literal>False</literal>) and
						<literal><![CDATA[3 < 5]]></literal> gives
						<literal>1</literal> (i.e. <literal>True</literal>).
						-->
						
						Vergleiche können beliebig aneinandergereiht werden:
						<!--Comparisons can be chained arbitrarily:-->
						
						<![CDATA[3 < 5 < 7]]> ergibt <literal>True</literal>.
						<!--<![CDATA[3 < 5 < 7]]> gives <literal>True</literal>.-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[>]]></entry>
						<entry>Größer als</entry><!--<entry>Greater Than</entry>-->
						<entry>
						
						Das Ergebnis zeigt an, ob x größer ist als y.
						<!--Returns whether x is greater than y-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[5 > 3]]></literal> ist wahr, ergibt also
						<literal>True</literal>. todo: If both operands are numbers, they
						are first converted to a common type. Otherwise, it always
						returns <literal>False</literal>.
						
						<!--
						<literal><![CDATA[5 < 3]]></literal> returns
						<literal>True</literal>. If both operands are numbers, they
						are first converted to a common type. Otherwise, it always
						returns <literal>False</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[<=]]></entry>
						<entry>Kleiner gleich</entry><!--<entry>Less Than or Equal To</entry>-->
						<entry>
						
						Das Ergebnis zeigt an, ob x kleiner als y oder gleich y ist
						<!--
						Returns whether x is less than or equal to y
						-->
						
						</entry>
						<entry>
						
						<literal><![CDATA[x = 3; y = 6; x <= y]]></literal>
						ergibt <literal>True</literal>.
						<!--
						<literal><![CDATA[x = 3; y = 6; x <= y]]></literal>
						returns <literal>True</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry><![CDATA[>=]]></entry>
						<entry>Größer gleich</entry><!--<entry>Greater Than or Equal To</entry>-->
						<entry>
						
						Das Ergebnis zeigt an, ob x größer als y oder gleich y ist
						<!--
						Returns whether x is greater than or equal to y
						-->
						
						</entry>
						<entry>
						
						<![CDATA[x = 4; y = 3; x >= 3]]> ergibt
						<literal>True</literal>.
						<!--
						<![CDATA[x = 4; y = 3; x >= 3]]> returns
						<literal>True</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>==</entry>
						<entry>Gleich</entry><!--<entry>Equal To</entry>-->
						<entry>
						
						Prüft die beiden Objekte auf Gleichheit
						<!--
						Compares if the objects are equal
						-->
						
						</entry>
						<entry>
						
						<literal>x = 2; y = 2; x == y</literal> ergibt
						<literal>True</literal>.
						<!--
						<literal>x = 2; y = 2; x == y</literal> returns
						<literal>True</literal>.
						-->
						
						<literal>x = 'str'; y = 'stR'; x == y</literal> ergibt
						<literal>False</literal>.
						<!--
						<literal>x = 'str'; y = 'stR'; x == y</literal> returns
						<literal>False</literal>.
						-->
						
						<literal>x = 'str'; y = 'str'; x == y</literal> ergibt
						<literal>True</literal>.
						<!--
						<literal>x = 'str'; y = 'str'; x == y</literal> returns
						<literal>True</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>!=</entry>
						<entry>Ungleich</entry><!--<entry>Not Equal To</entry>-->
						<entry>
						
						Prüft die beiden Objekte auf Ungleichheit
						<!--
						Compares if the objects are not equal
						-->
						
						</entry>
						<entry>
						
						<literal>x = 2; y = 3; x != y</literal> ergibt
						<literal>True</literal>.
						<!--
						<literal>x = 2; y = 3; x != y</literal> returns
						<literal>True</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>not</entry>
						<entry>Logisches NICHT</entry><!--<entry>Boolean NOT</entry>-->
						<entry>
						
						Bewirkt eine Invertierung des Wahrheitswertes. Wenn x <literal>True</literal>
						ist, ist das Ergebnis <literal>False</literal>. Wenn x <literal>False</literal> ist
						ist das Ergebnis <literal>True</literal>.
						<!--
						If x is <literal>True</literal>, it returns
						<literal>False</literal>. If x is <literal>False</literal>,
						it returns <literal>True</literal>.
						-->
						
						</entry>
						<entry>
						
						<literal>x = True; not y</literal> ergibt
						<literal>False</literal>.
						<!--
						<literal>x = True; not y</literal> returns
						<literal>False</literal>.
						-->
						
						</entry>
					</row>
					<row>
						<entry>and</entry>
						<entry>Logisches UND</entry><!--<entry>Boolean AND</entry>-->
						<entry>
						
						<literal>x and y</literal> ergibt <literal>False</literal>
						wenn x <literal>False</literal> ist. Andernfalls ist das Ergebnis der
						Wert von of y
						<!-- Kommentar: es waere sinnvoll fuer logische Operatoren die
						Wahrheitstafel anzugeben. -->
						
						<!--
						<literal>x and y</literal> returns <literal>False</literal>
						if x is <literal>False</literal>, else it returns evaluation
						of y
						-->
						
						</entry>
						<entry>
						
						<literal>x = False; y = True; x and y</literal> ergibt
						<literal>False</literal>, da x <literal>False</literal> ist.
						In diesem Fall wird der Python Interpreter die Variable y
						gar nicht erst in die Auswertung mit einbeziehen, da der Ausdruck
						bereits falsch ist (da x False ist). Diese Vereinfachung wird
						"short-circuit evaluation" genannt.
						
						<!--
						<literal>x = False; y = True; x and y</literal> returns
						<literal>False</literal> since x is False. In this case,
						Python will not evaluate y since it knows that the value of
						the expression will has to be false (since x is False).
						This is called short-circuit evaluation.
						-->
						
						</entry>
					</row>
					<row>
						<entry>or</entry>
						<entry>Logisches ODER</entry><!--<entry>Boolean OR</entry>-->
						<entry>
						
						Ergibt True, wenn x <literal>True</literal> ist. Andernfalls ist
						das Ergebnis der Wert von of y
						<!--
						If x is <literal>True</literal>, it returns True, else it
						returns evaluation of y
						-->
						
						</entry>
						<entry>
						
						<literal>x = True; y = False; x or y</literal> ergibt
						<literal>True</literal>. "Short-circuit evaluation" trifft hier
						ebenfalls zu.
						<!--
						<literal>x = True; y = False; x or y</literal> returns
						<literal>True</literal>. Short-circuit evaluation applies
						here as well.
						-->
						
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</section>
	
	<section id="operator-precedence">
		<title>Rangfolge der Operatoren</title><!--<title>Operator Precedence</title>-->
		
		<para>
		
		Wird bei einem Ausdruck wie z.B. <literal>2 + 3 * 4</literal> zuerst die Addition oder
		die Multiplikation durchgeführt? Wie wir aus der Schulmathematik wissen, kommt die
		Multiplikation zuerst - d.h. der Operator für die Multiplikation hat eine höhere Priorität
		gegenüber dem Operator für die Addition.
		
		<!--
		If you had an expression such as <literal>2 + 3 * 4</literal>, is the addition done first
		or the multiplication? Our high school maths tells us that the multiplication should be
		done first - this means that the multiplication operator has higher precedence than the
		addition operator.
		-->
		
		</para>
		<para>
		
		Nachfolgende Tabelle listet alle Operatoren in Python in der Reihenfolge ihrer Priorität.
		Aufsteigend, von der niedrigsten zur höchsten. D.h. der Python Interpreter wird bei einem
		Ausdruck zuerst die Operatoren auswerten, die in der Tabelle weiter unten stehen.
		
		<!--
		The following table gives the operator precedence table for Python, from the lowest
		precedence (least binding) to the highest precedence (most binding). This means that
		in a given expression, Python will first evaluate the operators lower in the table
		before the operators listed higher in the table.
		-->
		
		</para>
		<para>
		
		Die Tabelle soll hier nur zur Vervollständigung dienen
		(Sie finden diese auch im Python Referenz Handbuch). Ich rate Ihnen, Operatoren
		und Operanden mit Klammern zu gruppieren, um die Reihenfolge der Auswertung zu verdeutlichen.
		Das Programm wird dadurch auch lesbarer. Der Ausdruck <literal>2 + (3 * 4)</literal> ist z.B.
		viel klarer als
		<literal>2 + 3 * 4</literal>. Wie überall gilt es auch bei Klammern auf eine vernünftige
		Verwendung zu achten und diese wegzulassen, wo sie nicht gebraucht werden (wie
		bei <literal>2 + (3 + 4)</literal>).
		
		<!--
		The following table (same as the one in the Python reference manual) is provided for the
		sake of completeness. However, I advise you to use parentheses for grouping of operators
		and operands in order to explicitly specify the precedence and to make the program as
		readable as possible. For example, <literal>2 + (3 * 4)</literal> is definitely more clearer
		than <literal>2 + 3 * 4</literal>. As with everything else, the parentheses shold be used
		sensibly and should not be redundant (as in <literal>2 + (3 + 4)</literal>).
		-->
		
		</para>
		<table>
			<title>Rangfolge der Operatoren</title><!--<title>Operator Precedence</title>-->
			<tgroup cols="2">
				<thead>
					<row>
						<entry>Operator</entry>
						<entry>Bedeutung</entry><!--<entry>Description</entry>-->
					</row>
				</thead>
				<tbody>
					<row>
						<entry>lambda</entry>
						<entry>Lambda Funktion</entry><!--<entry>Lambda Expression</entry>-->
					</row>
					<row>
						<entry>or</entry>
						<entry>Logisches ODER</entry><!--<entry>Boolean OR</entry>-->
					</row>
					<row>
						<entry>and</entry>
						<entry>Logisches UND</entry><!--<entry>Boolean AND</entry>-->
					</row>
					<row>
						<entry>not x</entry>
						<entry>Logisches NICHT</entry><!--<entry>Boolean NOT</entry>-->
					</row>
					<row>
						<entry>in, not in</entry>
						<entry>Test auf Mitgliedschaft (in einer Sequenz)</entry>
						<!--<entry>Membership tests</entry>-->
					</row>
					<row>
						<entry>is, is not</entry>
						<entry>Test auf Identität</entry><!--<entry>Identity tests</entry>-->
					</row>
					<row>
						<entry><![CDATA[<, <=, >, >=, !=, ==]]></entry>
						<entry>Vergleiche</entry><!--<entry>Comparisons</entry>-->
					</row>
					<row>
						<entry>|</entry>
						<entry>Bitweises ODER</entry><!--<entry>Bitwise OR</entry>-->
					</row>
					<row>
						<entry>^</entry>
						<entry>Bitweises XOR (exclusives ODER)</entry><!--<entry>Bitwise XOR</entry>-->
					</row>
					<row>
						<entry><![CDATA[&]]></entry>
						<entry>Bitweises UND</entry><!--<entry>Bitwise AND</entry>-->
					</row>
					<row>
						<entry><![CDATA[<<, >>]]></entry>
						<entry>Bitweises schieben</entry><!--<entry>Shifts</entry>-->
					</row>
					<row>
						<entry>+, -</entry>
						<entry>Addition und Subtraktion</entry><!--<entry>Addition and subtraction</entry>-->
					</row>
					<row>
						<entry>*, /, %</entry>
						<entry>Multiplikation, Division und Modulo-Division</entry>
						<!--<entry>Multiplication, Division and Remainder</entry>-->
					</row>
					<row>
						<entry>+x, -x</entry>
						<entry>Positives- und Negatives Vorzeichen</entry><!--<entry>Positive, Negative</entry>-->
					</row>
					<row>
						<entry>~x</entry>
						<entry>Einer Komplement</entry><!--<entry>Bitwise NOT</entry>-->
					</row>
					<row>
						<entry>**</entry>
						<entry>Potenz</entry><!--<entry>Exponentiation</entry>-->
					</row>
					<row>
						<entry>x.attribut</entry><!--<entry>x.attribute</entry>-->
						<entry>Attributzugriff</entry><!--<entry>Attribute reference</entry>-->
					</row>
					<row>
						<entry>x[index]</entry>
						<entry>Indexierung</entry><!--<entry>Subscription</entry>-->
					</row>
					<row>
						<entry>x[index:index]</entry>
						<entry>Teilbereich einer Sequenz</entry><!--<entry>Slicing</entry>-->
					</row>
					<row>
						<entry>f(argumente ...)</entry><!--<entry>f(arguments ...)</entry>-->
						<entry>Funktionsaufruf</entry><!--<entry>Function call</entry>-->
					</row>
					<row>
						<entry>(objekt,..)</entry><!--<entry>(expressions, ...)</entry>-->
						<entry>todo:Tupel</entry><!--<entry>Binding or tuple display</entry>-->
					</row>
					<row>
						<entry>[objekt,..]</entry><!--<entry>[expressions, ...]</entry>-->
						<entry>todo:Liste</entry>
					</row>
					<row>
						<entry>{Schlüssel:Wert, ...}</entry><!--<entry>{key:datum, ...}</entry>-->
						<entry>todo:Dictionary</entry><!--<entry>Dictionary display</entry>-->
					</row>
					<row>
						<entry>todo:`expressions, ...`</entry><!--<entry>`expressions, ...`</entry>-->
						<entry>todo:String</entry><!--<entry>String conversion</entry>-->
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
		
		Die noch unbekannten Operatoren werden in den folgenden Abschnitten erklärt.
		
		<!--
		The operators which we have not already come across will be explained in later chapters.
		-->
		
		</para>
		<para>
		Operatoren mit <emphasis>gleicher Priorität</emphasis> sind in der obigen Tabelle
		in der gleichen Zeile aufgeführt. Die Operatoren <literal>+</literal> und <literal>-</literal>
		haben z.B. die gleiche Priorität.
		
		<!--
		Operators with the same <emphasis>same precedence</emphasis> are listed in the same row
		in the above table. For example, <literal>+</literal> and <literal>-</literal> have the
		same precedence.
		-->
		
		</para>
		<section id="order-of-evaluation">
			<title>Reihenfolge der Auswertung</title><!--<title>Order of Evaluation</title>-->
			
			<para>
			
			Normalerweise werden die Operatoren in der Reihenfolge wie in der Tabelle angegeben
			ausgewertet. Sie können diese Reihenfolge aber durch die Verwendung von Klammern
			ändern. Wenn Sie möchten, dass bei einem Ausdruck eine Addition vor einer Multiplikation
			ausgewertet wird, schreiben Sie <literal>(2 + 3) * 4</literal>.
			
			<!--
			By default, the operator precedence table decides which operators are evaluated
			before others. However, if you want to change the orer in which they are
			evaluated, you can use parentheses. For example, if you want addition to be
			evaluated before multiplication in an expression, then you can write something
			like <literal>(2 + 3) * 4</literal>.
			-->
			
			</para>
		</section>
		<section id="associativity">
			<title>Assoziativität</title><!--<title>Associativity</title>-->
			
			<para>
			
			Operatoren mit gleicher Priorität werden innerhalb eines Ausdrucks von links
			nach rechts ausgewertet. Z.b. wird <literal>2 + 3 + 4</literal> wie
			<literal>(2 + 3) + 4</literal> ausgewertet. Manche Operatoren, wie z.B. der
			Zuweisungsoperator, sind rechtsassoziativ. D.h. der Ausdruck <literal>a = b = c</literal>
			wird wie <literal>a = (b = c)</literal> behandelt.
			
			<!--
			Operators are usually associated from left to right i.e. operators with same
			precedence are evaluated in a left to right manner. For example,
			<literal>2 + 3 + 4</literal> is evaluated as
			<literal>(2 + 3) + 4</literal>. Some operators like assignment operators have
			right to left associativity i.e. <literal>a = b = c</literal> is treated as
			<literal>a = (b = c)</literal>.
			-->
			
			</para>
		</section>
	</section>
	
	<section id="expressions">
		<title>Ausdrücke</title><!--<title>Expressions</title>-->
		
		<section id="using-expressions">
			<title>Benutzung von Ausdrücken</title><!--<title>Using Expressions</title>-->
			
			<example>
				<title>Benutzung von Ausdrücken</title>
				<simpara>(<ulink url="code/ausdruck.py">ausdruck.py</ulink>)</simpara>
				<programlisting>
				<![CDATA[
#!/usr/bin/python

laenge = 5
breite = 2

flaeche = laenge * breite
print 'Die Flaeche ist', flaeche
print 'Der Umfang ist', 2 * (laenge + breite)
				]]>
<!--
				<![CDATA[
#!/usr/bin/python
# Filename: expression.py

length = 5
breadth = 2

area = length * breadth
print 'Area is', area
print 'Perimeter is', 2 * (length + breadth)
				]]>
-->
				
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title><!--<title>Output</title>-->
				<screen>
				<![CDATA[
$ python ausdruck.py
Die Flaeche ist 10
Der Umfang ist 14
				]]>
<!--
				<![CDATA[
$ python expression.py
Area is 10
Perimeter is 14
				]]>
-->
				
				</screen>
			</section>

			<section>
				<title>So funktioniert es</title><!--<title>How It Works</title>-->
				
				<para>
				
				Die Länge und die Breite des Rechtecks werden in zwei Variablen entsprechenden
				Namens gespeichert. Diese werden dann in den Ausdrücken verwendet um die Fläche und
				den Umfang zu berechnen. Wir speichern das Ergebnis des Ausdrucks 
				<literal>laenge * breite</literal> in der Variable <varname>flaeche</varname> und
				geben diese mit der <literal>print</literal> Anweisung auf dem Bildschirm aus.
				Im zweiten Fall wird direkt der Wert des Ausdrucks <literal>2 * (length + breadth)</literal>
				als Parameter für die <literal>print</literal> Anweisung verwendet.
				
				<!--
				The length and breadth of the rectangle are stored in variables by the
				same name. We use these to calculate the area and perimieter of the
				rectangle with the help of expressions. We store the result of the
				expression <literal>length * breadth</literal> in the variable
				<varname>area</varname> and then print it using the <literal>print</literal>
				statement. In the second case, we directly use the value of the expression
				<literal>2 * (length + breadth)</literal> in the print statement.
				-->
				
				</para>
				<para>
				
				Beachten Sie auch, wie 'hübsch' Python die Ausgabe macht. Obwohl wir zwischen
				<literal>'Die Flaeche ist'</literal> und der Variable <varname>flaeche</varname>
				kein Leerzeichen gemacht haben, fügt Python dieses für uns ein und wir
				erhalten wir eine schöne, klare Ausgabe. Dadurch ist auch unser Programmcode
				leichter zu lesen, da wir uns keine Sorgen um die Formatierung der Ausgabe machen
				müssen. Das ist ein Beispiel dafür, wie Python das Leben für Programmierer
				einfacher macht.
				
				<!--
				Also, notice how Python 'pretty-prints' the output. Even though we have not
				specified a space between <literal>'Area is'</literal> and the variable
				<varname>area</varname>, Python puts it for us so that we get a clean nice
				output and the program is much more readable this way (since we don't need
				to worry about spacing in the output). This is an example of how Python
				makes life easy for the programmer.
				-->
				
				</para>
			</section>
			
		</section>
	</section>
	
	<section id="operators-expressions-summary">
		<title>Zusammenfassung</title><!--<title>Summary</title>-->
		
		<para>
		
		In diesem Abschnitt haben wir gesehen, wie Operatoren, Operanden und Ausdrücke
		verwendet werden - sie sind die Basisbausteine für jedes Programm. Als nächstes
		werden wir sie zusammen mit Anweisungen in unseren Programmen verwenden.
		
		<!--
		We have seen how to use operators, operands and expressions - these are the basic
		building blocks of any program. Next, we will see how to make use of these in our
		programs using statements.
		-->
		
		</para>
	</section>
	
</chapter>