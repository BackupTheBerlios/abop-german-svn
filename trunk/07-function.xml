<chapter id="functions">

	<!-- German Translation 2005-03-01 by Bernhard Krieger -->

	<title>Funktionen</title><!--<title>Functions</title>-->
	
	<section id="function-intro">
		<title>Einführung</title><!--<title>Introduction</title>-->
		
		<para>
		
		Funktionen sind wiederverwendbare Teile eines Programmes. Sie ermöglichen es Ihnen einem Block
		von Statements einen Namen zu geben. Sie können dann diesen Block irgendwo in Ihrem Programm
		beliebig oft laufen lassen indem Sie den Namen benutzen. Das nennt man eine Funktion
		<emphasis>aufrufen</emphasis>. Wir haben bereits viele eingebauten Funktionen wie etwa
		<function>len</function> oder <function>range</function> verwendet.
		
		<!--
		Functions are reusable pieces of programs. They allow you to give a name to a block of
		statements and you can run that block using that name anywhere in your program and any
		number of times. This is known as <emphasis>calling</emphasis> the function. We have
		already used many built-in functions such as the <function>len</function> and
		<function>range</function>.
		-->
		
		</para>
		<para>
		
		Funktionen verwended das <emphasis role="bold">def</emphasis>ined <literal>def</literal>
		Schlüsselwort. Nach diesem folgt ein <emphasis>Identifikator</emphasis> Namen für die
		Funktion. Danach kommt ein Klammernpaar welches einige Variablennamen enthalten kann. Die Zeile
		endet mit einem Strichpunkt. Danach kommt der Block mit den Statements die zu der Funktion
		gehören. Ein Beispiel wird erläutern wie einfach das eigentlich ist:

		<!--		
		Functions are <emphasis role="bold">def</emphasis>ined using the <literal>def</literal>
		keyword. This is followed by an <emphasis>identifier</emphasis> name for the function
		followed by a pair of parentheses which may enclose some names of variables and the
		line ends with a colon. Next follows the block of statements that are part of this
		function. An example will show that this is actually very simple:
		-->
		
		</para>
		<section id="def-function">
			<title>Definition einer Funktion</title><!--<title>Defining a Function</title>-->
			
			<example>
				<title>Definition einer Funktion</title><!--<title>Defining a function</title>-->
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funktion1.py

def sagHallo():
	print 'Hallo Welt!' # Der Block gehoert zur Funktion
# Ende der Funktion

sagHallo() # die Funktion aufrufen
				]]>
				
<!--	
				<![CDATA[
#!/usr/bin/python
# Filename: function1.py

def sayHello():
	print 'Hello World!' # block belonging to the function
# End of function

sayHello() # call the function
				]]>
-->
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title><!--<title>Output</title>-->
				<screen>
				<![CDATA[
$ python funktion1.py
Hallo Welt!
				]]>
<!--	
				<![CDATA[
$ python function1.py
Hello World!
				]]>
-->
				</screen>
			</section>
			
			<section>
				<title>So funktioniert es</title><!--<title>How It Works</title>-->
				
				<para>
				
				Wir definieren eine Funktion <literal>sagHallo</literal> indem wir die Syntax
				verwenden die wir oben erklärt haben. Diese Funktion nimmt keine Parameter und
				deshalb sind auch keine Variablen in den Klammern eingefügt. Parameter sind für
				Funktionen nur Eingaben. Auf diese Weise können wir verschiedene Werte eingeben
				und entsprechende Resultate zurückbekommen.
				
				<!--
				We define a function called <literal>sayHello</literal> using the syntax
				as explained above. This function takes no parameters and hence there are
				no variables declared in the parentheses. Parameters to functions are just
				input to the function so that we can pass in different values to it and
				get back corresponding results.
				-->
				
				</para>
			</section>
		</section>
	</section>
	<section id="function-parameters">
		<title>Funktionsparameter</title><!--<title>Function Parameters</title>-->
		
		<para>
		Eine Funktion kann als Parameter Werte verarbeiten die Sie der Funktion zufügen um sie etwas
		damit <emphasis>anfangen</emphasis> zu lassen. Diese Parameter verhalten sich genauso wie
		herkömmliche Variablen, nur dass deren Werte nicht innerhalb der Funktion zugewiesen werden
		sondern beim Aufruf der Funktion definiert werden.

		<!--
		A function can take parameters which are just values you supply to the function so
		that the function can <emphasis>do</emphasis> something utilising those values. These
		parameters are just like variables except that the values of these variables are defined
		when we call the function and are not assigned values within the function itself.
		-->
		
		</para>
		<para>
		
		Parameter werden innerhalb des Klammernpaars der Funktionsdefinition festgelegt und mit Kommata
		voneinander getrennt. Wenn wir die Funktion später aufrufen legen Sie die Werte auf gleiche Weise
		fest. Beachten Sie aber die Terminologie. Während die Namen in der Funktionsdefinition
		<emphasis>Parameter</emphasis> heissen, werden die Werte die Sie im Funktionsaufruf
		spezifizieren <emphasis>Argumente</emphasis> genannt.
		
		<!--
		Parameters are specified within the pair of parentheses in the function definition,
		separated by commas. When we call the function, we supply the values in the same way.
		Note the terminology used - the names given in the function definition are called
		<emphasis>parameters</emphasis> whereas the values you supply in the function call are
		called <emphasis>arguments</emphasis>.
		-->
		
		</para>
		
		<section>
			<title>Funktionsparameter benutzen</title><!--<title>Using Function Parameters</title>-->
			
			<example>
				<title>Funktionsparameter benutzen</title><!--<title>Using Function Parameters</title>-->
				
				<programlisting>
				
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_param.py

def printMax(a, b):
	if a > b:
		print a, 'ist groesser'
	else:
		print b, 'ist groesser'
	
printMax(3, 4) # nimmt reale Zahlen als Argumente

x = 5
y = 7

printMax(x, y) # nimmt Variablen als Argumente
				]]>

<!--
				<![CDATA[
#!/usr/bin/python
# Filename: func_param.py

def printMax(a, b):
	if a > b:
		print a, 'is maximum'
	else:
		print b, 'is maximum'
	
printMax(3, 4) # directly give literal values

x = 5
y = 7

printMax(x, y) # give variables as arguments
				]]>
-->
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title><!--<title>Output</title>-->
				
				<screen>
				<![CDATA[
$ python funk_param.py
4 ist groesser
7 ist groesser
				]]>
<!--
				<![CDATA[
$ python func_param.py
4 is maximum
7 is maximum
				]]>
-->
				</screen>
			</section>
			
			<section>
				<title>So funktioniert es</title><!--<title>How It Works</title>-->
				
				<para>
				
				Wir definieren eine Funktion <function>printMax</function> mit zwei Variablen
				<varname>a</varname> und <varname>b</varname>. Wir berechnen die größere Zahl
				indem wir ein einfaches <literal>if..else</literal> Statement verwenden und den
				größeren Wert ausdrucken.

				<!--
				Here, we define a function called <function>printMax</function> where we
				take two parameters called <varname>a</varname> and <varname>b</varname>.
				We find out the greater number using a simple <literal>if..else</literal>
				statement and then print the bigger number.
				-->
				
				</para>
				<para>
				
				Im ersten Fall liefern wir <function>printMax</function> direkt Zahlen als
				Argumente. Im zweiten Fall rufen wir die Funktion auf und verwenden Variablen.
				<literal>printMax(x, y)</literal> bewirkt daß der Wert des Argumentes
				<varname>x</varname> dem Parameter <varname>a</varname> zugeschrieben
				wird und der Wert des Argumentes <varname>y</varname> dem Parameter
				<varname>b</varname>. In beiden Fällen arbeitet die printMax Funktion gleich.
				
				<!--
				In the first usage of <function>printMax</function>, we directly supply the
				numbers i.e. arguments. In the second usage, we call the function using
				variables. <literal>printMax(x, y)</literal> causes value of argument
				<varname>x</varname> to be assigned to parameter <varname>a</varname> and
				the value of argument <varname>y</varname> assigned to parameter
				<varname>b</varname>. The printMax function works the same in both the cases.
				-->
				
				</para>
			</section>
		</section>
	</section>
	
	<section id="local-variables">
		<title>Lokale Variablen</title><!--<title>Local Variables</title>-->
		
		<para>
		
		Wenn wir Variablen innerhalb einer Funktion definieren haben diese nichts mit irgendwelchen
		anderen	Variablen des gleichen Namens zu tun, die außerhalb der Funktion benutzt werden.
		Das heisst, daß	Variable immer <emphasis>lokal</emphasis> zur Funktion sind. Das nennt man
		<emphasis>Raum</emphasis> einer Variablen. Alle Variablen haben den Raum desjenigen Blockes
		in welchem sie erklärt sind, beginnend mit dem Punkt an dem der Name definiert wird. 
		
		<!--
		When you declare variables inside a function definition, they are not related in any way
		to other variables with the same names used outside the function i.e. variable names are
		<emphasis>local</emphasis> to the function. This is called the <emphasis>scope</emphasis>
		of the variable. All variables have the scope of the block they are declared in starting
		from the point of definition of the name.
		-->
		
		</para>
		
		<section>
			<title>Lokale Variablen benutzen</title><!--<title>Using Local Variables</title>-->
			
			<example>
				<title>Lokale Variablen benutzen</title><!--<title>Using Local Variables</title>-->
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python

def funk(x):
	print 'x ist', x
	x = 2
	print 'Aendert lokales x zu', x

x = 50
funk(x)
print 'x ist immernoch', x
				]]>
<!--
				<![CDATA[
#!/usr/bin/python
# Filename: func_local.py

def func(x):
	print 'x is', x
	x = 2
	print 'Changed local x to', x

x = 50
func(x)
print 'x is still', x
				]]>
-->
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title><!--<title>Output</title>-->
				
				<screen>
				<![CDATA[
$ python funk_local.py
x ist 50
Aendert locales x zu 2
x ist immernoch 50
				]]>
<!--
				<![CDATA[
$ python func_local.py
x is 50
Changed local x to 2
x is still 50
				]]>
-->
				</screen>
			</section>
			
			<section>
				<title>So funktioniert es</title><!--<title>How It Works</title>-->
				
				<para>
				
				Wenn wir das erste mal in der Funktion den <emphasis>Wert</emphasis>
				des Namens <varname>x</varname> benÃ¼tzen, verwendet Python den Wert des 				Parameters, der in der Funktion erklÃ¤rt wird.
				
				</para>
				<para>
				
				Als nÃ¤chstes weisen wir den Wert <literal>2</literal> <varname>x</varname> zu. 				Der Name <varname>x</varname> ist lokal innerhalb der Funktion. Wenn wir also 				den Wert von <varname>x</varname> in der Funktion verÃ¤ndern, wird das					<varname>x</varname> das im Hauptblock definiert wurde davon nicht 					betroffen. 
				
				</para>
				<para>
				
				Durch das letzte <literal>print</literal> Statement bestÃ¤tigen wir, daÃŸ der Wert von 				<varname>x</varname> im Hauptblock unverÃ¤ndert bleibt. 
				
				</para>
			</section>
		</section>
		
		<section id="global">
			<title>Globale Statements benutzen</title>
			
			<para>
			
			Wenn Sie einem Namen einen Wert zuweisen wollen der auÃŸerhalb der Funktion definiert 			wird mÃ¼ssen Sie Python mitteilen, daÃŸ der Name nicht lokal sondern 						<emphasis>global</emphasis> ist. Wir kÃ¶nnen das mit dem <literal>global</literal> 				Statement erreichen. Es ist unmÃ¶glich einer Variablen einen Wert zuzuweisen, die auÃŸerhalb 			der Funktion ohne ein <literal>global</literal> Statement zu verwenden. 
			
			</para>
			<para>
			
			Sie kÃ¶nnen die Werte auÃŸerhalb der Funktion definierter Variablen benÃ¼tzen (vorausgesetzt, 			daÃŸ keine Variable des gleichen Names innerhalb der Funktion existiert). Das wird jedoch 			nicht empfohlen und sollte vermieden werden da es einem Leser des Programcodes nicht 			sofort klar ist, wo die Variable definiert wurde. Indem man das <literal>global</literal> 			Statement benutzt wird es klar, daÃŸ die Variable auÃŸerhalb des Blocks definiert wurde. 
			
			</para>
			
			<example>
				<title>Globale Statements benutzen</title>
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_global.py

def funk():
	global x

	print 'x ist', x
	x = 2
	print 'Globales x Ã¤ndern in ', x

x = 50
funk()
print 'Der Wert von x ist ', x
				]]>
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title>
				
				<screen>
				<![CDATA[
$ python funk_global.py
x ist 50
Globales x Ã¤ndern in  2
Der Wert von x ist 2
				]]>
				</screen>
			</section>
			
			<section>
				<title>WieÂ´s funktioniert</title>
				
				<para>

				Das <literal>global</literal> Statement wird benutzt um <varname>x</varname> als 				globale Variable zu erklÃ¤ren. Wenn wir also <varname>x</varname> einen Wert 				innerhalb der Funktion zuweisen wird diese VerÃ¤nderung berÃ¼cksichtigt wenn wir 				den Wert <varname>x</varname> im Hauptblock benutzen.
				
				</para>
				<para>
				
				Sie kÃ¶nnen mehr als eine globale Variable spezifizieren indem Sie das selbe 					<literal>global</literal> Statement benutzen. Zum Beispiel <literal>global x, y, 				z</literal>.
				
				</para>
			</section>
		</section>
	</section>
	
	<section id="default-argument-values">
		<title>Voreingestellte Werte fÃ¼r Argumente</title>
	
		<para>
		
		Bei einigen Funktionen mÃ¶chten Sie vielleicht <emphasis>optionale</emphasis> Parameter 			verwenden und voreingestellte Werte angeben fÃ¼r den Fall, daÃŸ der Benutzer keine Werte zur 			VerfÃ¼gung stellen will. Das kann man mit voreingestellten Argumentwerten erreichen. Sie kÃ¶nnen 		voreingestellte Argumentwerte fÃ¼r Parameter spezifizieren indem Sie in der Funktionsdefinition nach 		dem Parameternamen den Zuweisungsoperator (<literal>=</literal>) setzen und danach den 			voreingestellten Wert angeben. 
		
		</para>
		<para>
		
		Beachten Sie, daÃŸ der voreingestellte Wert fÃ¼r das Argument eine Konstante sein sollte. Der 			voreingestellte Wert sollte unverÃ¤nderbar sein. Wir werden das in den nÃ¤chsten Kapiteln nÃ¤her 			erklÃ¤ren. Behalten Sie das fÃ¼r den Moment in Erinnerung. 
		
		</para>
		
		<section>
			<title>Voreingestellte Werte fÃ¼r Argumente </title>
			
			<example>
				<title>Voreingesellte Werte fÃ¼r Argumente verwenden</title>
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_default.py

def sag(nachricht, wiederholungen = 1):
	print nachricht * wiederholungen

sag('Hallo')
sag('Welt', 5)
				]]>
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title>
				
				<screen>
				<![CDATA[
$ python funk_default.py
Hallo
WeltWeltWeltWeltWelt
				]]>
				</screen>
			</section>
			
			<section>
				<title>WieÂ´s funktioniert</title>
				
				<para>
				
				Die Funktion <function>sag</function> wird verwendet um einen String sooft 					auszugeben wie man will. Wenn wir keinen Wert spezifizieren wird der String â€“ wie 				vorher eingestellt â€“ nur einmal ausgegeben. Wir erreichen das indem wir zuvor den 				voreingesellten Argumentwert <literal>1</literal> fÃ¼r den Parameter 						<varname>wiederholungen</varname> angeben. 
				
				</para>
				<para>
							
				Bei der ersten Verwendung von <function>sag</function> geben wir nur den String 				an sodaÃŸ dieser einmal ausgegeben wird. Wenn wir <function>sag</function> zum 				zweiten mal verwenden geben wir sowohl den String an, als auch ein Argument 				<literal>5</literal>. Damit geben wir an, daÃŸ <emphasis>sag</emphasis> den String 				<literal>nachricht</literal> 5 mal ausgeben soll. .
				
				</para>
				<important>
					<para>
					
					Nur Parameter am Ende der Parameterliste kÃ¶nnen voreingesellte Werte 					besitzen. Das bedeutet, daÃŸ kein Parameter mit einem voreingesellten 						Argumentwert vor einem Parameter ohne voreingesellten Argumentwert 					stehne kann. 
			
					</para>
					<para>
					
					Das ist deshalb der Fall, da die Werte den Parametern durch Ihre Position 					zugewiesen werden. Zum Beispiel <literal>def funk(a, b=5)</literal> ist 					gÃ¼ltig, aber <literal>def funk(a=5, b)</literal> ist 								<emphasis>ungÃ¼ltig</emphasis>.
					
					</para>
				</important>
			</section>
		</section>
	</section>
	
	<section id="keyword-arguments">
		<title>SchlÃ¼sselwortargumente</title>
		
		<para>
		
		Wenn Sie Funktionen mit mehreren Parametern haben und nur einige von ihnen spezifizieren 			wollen so kÃ¶nnen Sie Werte fÃ¼r diese Parameter zur VerfÃ¼gung stellen indem Sie sie benennen. Das 		nennt man <emphasis>SchlÃ¼sslewortargumente</emphasis>. Anders als zuvor benÃ¼tzen wir den 			Namen (SchlÃ¼sselwort) anstelle der Position um die Argumente der Funktion zu spezifizieren. 

		</para>
		<para>
		
		DafÃ¼r gibt es zwei <emphasis>Vorteile</emphasis>. Erstens: Es ist leichter eine Funktion zu 			verwenden, da man sich keine Gedanken Ã¼ber die Reihenfolge der Argumente machen muÃŸ. Zweites: 		Wir kÃ¶nnen  ausschlieÃŸlich denjenigen Parametern Werte zuordnen bei denen wir das auch wollen, 		vorausgesetzt die anderen Parameter haben voreingesellte Werte. 
		
		</para>
		
		<section>
			<title>SchlÃ¼sselwortargumente benutzen</title>
			
			<example>
				<title>SchlÃ¼sselwortargumente benutzen</title>
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_key.py

def funk(a, b=5, c=10):
	print 'a ist', a, 'und b ist', b, 'und c ist', c

funk(3, 7)
funk(25, c=24)
funk(c=50, a=100)
				]]>
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title>
				
				<screen>
				<![CDATA[
$ python funk_key.py
a ist 3 und b ist 7 und c ist 10
a ist 25 und b ist 5 und c ist 24
a ist 100 und b ist 5 und c ist 50
				]]>
				</screen>
			</section>
			
			<section>
				<title>Wie's funktioniert</title>
				
				<para>
				
				Die Funktion <function>funk</function> hat einen Parameter ohne voreingesellten 				Wert gefolgt von zwei Parametern mit voreingesellten Argumentwerten. 
				
				</para>
				<para>
				
				Wenn wir die Funktion zum ersten mal benutzen, <literal>funk(3, 7)</literal>, 					bekommt der Parameter <varname>a</varname> den Wert <literal>3</literal>, der 				Parameter <varname>b</varname> den Wert <literal>5</literal> und 						<varname>c</varname> den voreingestellten Wert <literal>10</literal>.
				
				</para>
				<para>
				
				Beim zweiten Gebrauch von <literal>funk(25, c=24)</literal>, bekommt die 					Variable <varname>a</varname> den Wert 25 wegen der Position des Argumentes. 				Danach bekommt der Parameter <varname>c</varname> den Wert 						<literal>24</literal> wegen der Benennung als SchlÃ¼sselwortarguments. Die 					Variable <varname>b</varname> erhÃ¤lt den voreingesellten Wert 						<literal>5</literal>.
				
				</para>
				<para>
				
				

				Beim dritten Gebrauch von <literal>funk(c=50, a=100)</literal>, benutzen wir 				ausschlieÃŸlich SchlÃ¼sselwortargumente um die Werte zu spezifizieren. Beachten Sie, 				daÃŸ wir den Wert des Parameters <varname>c</varname> vor dem des Parameters 				<varname>a</varname> spezifizieren, auch wenn <varname>a</varname> innerhalb 				der Funktionsdefinition vor <varname>c</varname> benannt wird. 
				
				</para>
			</section>
		</section>
	</section>
	
	<section id="return">
		<title>Das return Statement</title>
		
		<para>
		
		Das <literal>return</literal> Statement wird benutzt um von einer Funktion 					<emphasis>zurÃ¼ck</emphasis> zu gehen. Das bedeutet aus einer Funktion herauszugehen. Wahlweise 		kÃ¶nnen wir einen <emphasis>Wert der Funktion zurÃ¼ckgeben</emphasis> lassen.
		
		</para>
		
		<section>
			<title>WÃ¶rtliche Statements benutzen</title>
			
			<example>
				<title>WÃ¶rtliche Statements benutzen </title>
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_return.py

def maximum(x, y):
	if x > y:
		return x
	else:
		return y

print maximum(2, 3)
				]]>
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title>
				
				<screen>
				<![CDATA[
$ python funk_return.py
3
				]]>
				</screen>
			</section>
			
			<section>
				<title>WieÂ´s funktioniert</title>
				
				<para>
				
				Die Funktion <function>maximum</function> gibt den grÃ¶ÃŸten der Parameter 					zurÃ¼ck. In diesem Fall sind dies Zahlen, die der Funktion als Argumente zugefÃ¼hrt 				wurden. Sie benutzt ein einfaches <literal>if..else</literal> Statement um den 					grÃ¶ÃŸeren der Werte zu finden und gibt dann diesen Wert 							<emphasis>zurÃ¼ck</emphasis>.
				
				</para>
				<para>
				
				Beachten Sie daÃŸ ein <literal>return</literal> Statement ohne Wert das gleiche ist 				wie eine <literal>return None</literal> Statement. <literal>None</literal> ist eine 				besondere Art und Weise in Python Nichts zu representieren. Man benÃ¼tzt es etwa 				um auszudrÃ¼cken, daÃŸ eine Variable keinen Wert hat wenn es einen Wert von 					<literal>None</literal> besitzt. 
				
				</para>
				<para>
				
				Jede Funktion enthÃ¤lt implizit ein <literal>return None</literal>
				Statement am Ende auÃŸer Sie haben Ihr eigenes <literal>return</literal>
				Statement geschrieben. Sie kÃ¶nnen das sehen indem sie <literal>print eineFunktion()				</literal> ausfÃ¼hren lassen wobei die Funktion <function>eineFunktion</function> 				kein <literal>return</literal> Statement verwendet:
				
				</para>
				<programlisting>
				<![CDATA[
def eineFunktion():
	pass
				]]>
				</programlisting>
				<para>
				
				Das <literal>pass</literal> Statement wird in Python benutzt um einen leeren Block 				anzugeben.
				
				</para>
			</section>
		</section>
	</section>
	<section id="docstrings">
		<title>DocStrings</title>
		
		<para>
		
		Python hat eine elegantes Dokumentationsfeature names <emphasis>documentation 				strings</emphasis> wobei man normalerweise den kÃ¼rzeren Namen 						<emphasis>docstrings</emphasis> benutzt. DocStrings ist ein wichtiges Werkzeug von dem Sie 			Gebrauch machen sollten da es dazu beitrÃ¤gt das Program zu dokumentieren und es besser zu 			verstehen. Erstaunlicherweise kÃ¶nnen wir sogar die DocStrings â€“ etwa einer Funktion â€“ wÃ¤hrend des 		Programablaufs zurÃ¼ckbekommen! 

		</para>
		
		<section>
			<title>DocStrings benutzen</title>
			
			<example>
				<title>DocStrings benutzen</title>
				
				<programlisting>
				<![CDATA[
#!/usr/bin/python
# Dateiname: funk_doc.py

def printMax(x, y):
	'''Gibt die grÃ¶ÃŸere von zwei Zahlen aus.

	Die beiden Werte mÃ¼ssen natÃ¼rliche Zahlen sein.'''
	x = int(x) # wandelt wenn mÃ¶glich in natÃ¼rliche Zahlen um
	y = int(y)

	if x > y:
		print x, 'ist die grÃ¶ÃŸere der beiden Zahlen'
	else:
		print y, 'ist die grÃ¶ÃŸere der beiden Zahlen'

printMax(3, 5)
print printMax.__doc__
				]]>
				</programlisting>
			</example>
			
			<section>
				<title>Ausgabe</title>
				
				<screen>
				<![CDATA[
$ python funk_doc.py
5  ist die grÃ¶ÃŸere der beiden Zahlen
Gibt die grÃ¶ÃŸere von zwei Zahlen aus.

Die beiden Werte mÃ¼ssen natÃ¼rliche Zahlen sein.
				]]>
				</screen>
			</section>
			
			<section>
				<title>WieÂ´s funtioniert</title>
				
				<para>
				
				Ein String in der ersten logischen Zeile einer Funktion ist der 
				<emphasis>docstring</emphasis> fÃ¼r diese Funktion. Beachten Sie daÃŸ man 					DocStrings auch fÃ¼r <link linkend="modules">Module</link> und 
				<link linkend="classes">Klassen</link> verwenden kann, von denen wir in den 				entsprechenden Kapiteln noch lernen werden. 
				
				</para>
				<para>
				
				Die Konvention die bei docstrings verwendet wird ist eine mehrzeiliger String wobei 				die erste Zeile mit einem GroÃŸbuchstaben beginnt und mit einem Punkt aufhÃ¶rt. 				Danach bleibt die zweite Zeile leer. Danach kommt eine detailierte ErklÃ¤rung, 					beginnend in Zeile drei. Es wird <emphasis>ausdrÃ¼cklich geraten</emphasis> 					dieser Konvention in allen docstrings fÃ¼r alle nicht trivialen Funktionen zu folgen.  
				
				</para>
				<para>
				
				Wir erhalten den docstring der <function>printMax</function> Funktion
				indem wir die <literal>__doc__</literal> Eigenschaft (welche nicht zur Funktion 				selbst gehÃ¶rt) der Funktion benutzen (beachten Sie den doppelten Unterstrich). 				Merken Sie sich einfach daÃŸ Python <emphasis>alles</emphasis> als Objekt 					behandelt. Das schlieÃŸt auch Funktionen ein. Wir werden mehr Ã¼ber Objekte in dem 				Kapitel Ã¼ber <link linkend="oops">Klassen</link> lernen.
				
				</para>
				<para>
				
				Wenn Sie <literal>help()</literal> in Python benutzt haben, haben Sie bereits den 				Gebrauch von docstrings gesehen! <literal>help()</literal> holt nur die 					<varname>__doc__</varname> Eigenschaft einer Funktion hervor und gibt Sie in 				einer netten Weise fÃ¼r Sie aus. Sie kÃ¶nnen das mit der obigen Funktion ausprobieren. 				FÃ¼gen Sie nur <literal>help(printMax)</literal> in Ihr Program ein. Vergessen Sie 				nicht die Taste <keycap>q</keycap> zu drÃ¼cken um die <literal>Hilfe</literal> zu 				verlassen.
				
				</para>
				<para>
				
				Auf diese Weise kÃ¶nnen automatisierende Werkzeuge die Dokumentation Ihres 				Programmes abrufen. Deshalb wird <emphasis>ausdrÃ¼cklich geraten</emphasis> 				docstrings fÃ¼r jede nicht trivial Funktion die Sie schreiben zu benÃ¼tzen. Der 					<command>pydoc</command> Befehle, der in Ihrer Python Distribution enthalten 				ist arbeitet Ã¤hlich wie <literal>help()</literal> indem es docstrings verwendet.
				
				</para>
			</section>
		</section>
	</section>
	
	<section id="functions-summary">
		<title>Zusammenfassung</title>
		
		<para>
		
		Wir haben viele Aspekte von Funktionen kennengelernt, aber beachten Sie, daÃŸ wir immernoch nicht 		alles darÃ¼ber wissen. Jedoch haben wir das meiste erfahren, das Sie in Sachen Python 				Funktionen fÃ¼r den tÃ¤glichen Gebrauch wissen sollten. 
		
		</para>
		<para>
		
		Als nÃ¤chstes werden wir lernen wie wir Python Module verwenden und erzeugen. 
		
		</para>
	</section>
</chapter>